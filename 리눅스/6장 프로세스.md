# 6장 프로세스

## 프로세스 개념

간단하게 말해서 **실행 중인 프로그램**이다.

![Untitled](https://user-images.githubusercontent.com/101644572/173226834-f637628b-cb3d-4b79-8ab0-b3909311fff0.png)

비동기적 행위로 운영체제가 시스템 버스를 통해 메모리에 **적재**된 프로그램을 프로세스라 부른다.

- 프로세서 : CPU

<br>

### **메모리 구조** (사용자 관점)

![Untitled 1](https://user-images.githubusercontent.com/101644572/173226896-d03fdcd1-0296-4e4c-8a86-f06f372662d0.png)


- 메모리는 사용자, 커널 관점으로 구성
- 스택, 힙 공간은 동적 메모리 공간, 그 사이 공간은 스택에 공간이 부족하면 사용.
    - **스택** : 지역변수 저장, 후입선출 자료구조
    - **힙** : 동적 메모리 할당, 메모리를 알차게 사용
    - **데이터 :** 전역변수 저장
    - **코드** : 프로그램 코드를 컴파일하여 기계어로 저장
- 프로그램 카운터의 값이 메모리의 다음 번지를 가리키며 다음 프로그램을 알려준다.

### 프로세스 종류

**시스템(커널) 프로세스**

- 모든 시스템 메모리, 프로세서의 명령에 액세스할 수 있는 프로세스
- 프로세스 실행 순서 제어, 다른 영역 침범 못하게 감시, 사용자 프로세스 생성

**사용자 프로세스**

- 사용자 코드를 수행하는 프로세스

**독립 프로세스**

- 다른 프로세스에 영향을 주지도, 받지도 않으며 수행하는 병행 프로세스

**협력 프로세스**

- 다른 프로세스에 영향을 주거나 받는 병행 프로세스

<br>

### 프로세스 명령어

- **$ ps [-옵션]** : 현재 시스템 내의 프로세스들의 실행 상태 요약하여 출력
    - -a : 모든 사용자 프로세스 출력
    - -u : 프로세스에 대한 자세한 정보 출력
    - -x : 더 이상 제어 터미널을 갖지 않은 프로세스들도 출력

![Untitled 2](https://user-images.githubusercontent.com/101644572/173226908-6556b9df-6c43-4599-9df6-9035fedd97ab.png)


- **$ pgrep [-옵션] [패턴]** : 패턴에 해당하는 프로세스들만 리스트
    - -l : PID와 함께하는 프로세스의 이름 출력
    - -f : 명령어의 경로도 출력
    - -n : 가장 최근 프로세스만 출력
    - -x : 패턴과 정확하게 일치되는 프로세스만 출력
    

<br>
<br>

## 쉘과 프로세스

1. 프롬프트를 내고 명령어를 입력
2. 자식 프로세스 생성
3. 자식 프로세스에게 명령어를 실행 → 1번으로 돌아감

<br>

### 작업 제어

**$ 명령어 &**

- 후면 작업으로 실행

**$ sleep 초** 

- 명시된 시간만큼 프로세스 실행을 중지
- ex) $ (echo 시작; sleep 5; echo 끝)
- Ctrl + C : 강제 종료
- Ctrl + Z : 실행 중지

**$ fg**

- **정지된 작업**을 다시 전면에서 실행
- $ fg %작업번호 : 작업번호에 해당된 작업을 전면에서 실행

**$ bg %작업번호**

- 작업번호에 해당하는 **중지된 작업**을 후면으로 실행
- Ctrl + Z 로 전면 실행 중인 작업을 중지 시킨 후, bg 명령어 사용 가능

**$ kill 프로세스번호**

**$ kill %작업번호**

- 프로세스번호 또는 작업번호에 해당하는 프로세스를 강제 종료

**$ wait [프로세스번호]**

- 프로세스 번호로 지정한 자식 프로세스가 종료될 때까지 기다리기
- 번호 지정하지 않을 시 모든 자식 프로세스가 끝나기를 기다림

<br>

## 프로세스의 사용자 ID

각 프로세스는 실제 사용자 ID와 유효 사용자 ID를 가진다

**$ id [사용자명]** : 사용자의 실제ID, 유효 사용자 ID, 그롭 ID등을 보여준다.

<br>

**프로세스의 실제 사용자 ID**

- 프로세스를 실행시킨 사용자의 ID로 설정됨

**프로세스의 유효 사용자 ID**

- 현재 유효한 사용자 ID
- 보통 유효 사용자 ID와 실제 사용자 ID는 같다.
- 새로 파일을 만들 때나 파일의 접근권한을 검사할 때 주로 사용
- 특별한 실행파일 실행 → 유효 사용자 ID는 달라짐

<br>

### Setuid와 Setgid

![Untitled 3](https://user-images.githubusercontent.com/101644572/173226943-0b8b64d2-f658-4295-873b-e8e854b14094.png)


**set-user-id 실행파일**

- setuid가 설정된 실행파일을 실행하면 → 이 프로세스의 유효 사용자 ID는 실행파일의 소유자로 바뀜 → 프로세스가 실행되는 동안 그 파일의 소유자 권한을 가지게 됨
- $ chmod **4**755 파일/ $ chomd u+s 파일

**set-group-id 실행파일**

- 실행되는 동안에 그 파일 소유자의 그룹을 프로세스의 유효 그룹 ID로 갖게된다.
- $ chmod **2**755 파일/ $ chomd g+s 파일

<br>

## 시그널

예상치 못한 상황 발생 시 알려주는 소프트웨어 인터럽트

- 운영체제가 실행되는 프로세스에게
- 인터럽트 : 명령을 수행(처리)하는 cpu를 멈추게 하는 것
- 실행 중인 프로세스는 메모리에 있고, 중지된 프로세스는 가상 메모리(하드 디스크)에 존재.

<br>

**$ kill [-시그널] 프로세스번호**

**$ kill [-시그널] %작업번호**

- 프로세스번호/작업번호로 지정된 프로세스에 원하는 시그널 보내기
- 시그널을 명시하지 않으면 해당 프로세스 강제 종료
- $ kill -l 명령어로 정의된 모든 가능한 시그널을 리스트 해줌.
