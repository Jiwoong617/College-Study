# 12장 파일 시스템과 파일 입출력

**$ df 파일시스템** : 파일 시스템에 대한 **디스크 사용 정보**를 보여줌

**$ du [-s] 파일명** : 파일/디렉터리의 **사용량** 보여줌, 명시하지 않으면 현재 디렉터리 내 모든 파일들의 사용 공간 보여줌 (-s = sum)

## 파일 시스템 구조

![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8E%E1%85%AE%E1%86%AF%E1%84%85%E1%85%A7%E1%86%A8%208075bcd7b0f7404aa6836d67f26703b3/Untitled.png)

**부트 블록**

- 파일 시스템 시작부에 위치하고 보통 첫 번째 섹터를 차지
- 부트스트랩 코드(첫 실행코드)가 저장되는 블록

**슈퍼 블록**

- 전체 파일 시스템에 대한 정보를 저장

**i-리스트**

- i-노드의 리스트, 1개의 블록은 약 40개의 i-노드 포함
- i-node : 파일의 전체적 속성 저장, 1개의 파일은 1개의 i-노드를 가짐
    - 디렉터리는 디렉터리 엔트리 i-node 번호를 통해 파일/디렉터리 접근

**데이터 블록**

- 파일의 내용(데이터)을 저장하기 위한 블록

### 파일 상태 정보

**파일 상태** 

- 파일에 대한 모든 정보
- 블록수, 파일 타입, 접근권한, 링크 수, 파일 소유자의 사용자 id, 그룹 id, 파일 크기, 최종 수정 시간
- **$ ls -l 파일**
- **$ stat 파일**

### i-노드

- 한 파일은 하나의 i-노드를 갖는다
- 파일에 대한 모든 정보를 가지고 있음

![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8E%E1%85%AE%E1%86%AF%E1%84%85%E1%85%A7%E1%86%A8%208075bcd7b0f7404aa6836d67f26703b3/Untitled%201.png)

### i-노드와 블록 포인터

![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8E%E1%85%AE%E1%86%AF%E1%84%85%E1%85%A7%E1%86%A8%208075bcd7b0f7404aa6836d67f26703b3/Untitled%202.png)

- **블록 포인터 :** 데이터 블록에 대한 포인터, 파일의 내용을 저장하기 위해 할당된 데이터 블록의 주소
- i-노드 내의 블록 포인터
    - 직접 블록 포인터 12개
    - 간접 블록 포인터 1개
    - 이중 간접 블록 포인터 1개
    

### 디렉터리

디렉터리를 위한 별도의 구조는 없다

- 디렉터리도 일종의 파일로 다른 파일처럼 구현
- 디렉터리도 다른 파일처럼 하나의 i-노드로 표현
- 디렉터리의 내용은 디렉터리 엔트리(파일 이름, i-노드 번호)이다

![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8E%E1%85%AE%E1%86%AF%E1%84%85%E1%85%A7%E1%86%A8%208075bcd7b0f7404aa6836d67f26703b3/Untitled%203.png)

**/usr/test.c를 간다고 가정 할때**

1. 루트의 i-node는 2, 즉 디렉터리 내용은 2번 i-노드의 직접 블록 포인터가 가리키는 200번 데이터 블록에 저장
2. 200번 데이터 블록 내 디렉터리 엔트리를 보면 usr i-노드는 4
3. 4로 이동 후, 블록 포인터가 가리키는 202로 이동
4. 202의 디렉터리 엔트리 → test.c i-노드는 6
5. 6으로 이동, test.c의 첫번째 블록 204로 이동.

### 링크

**$ ln [-s] 파일1 파일2 :** 파일1에 대한 새로운 이름(링크)로 파일2를 만들어 준다. -s 옵션은 심볼릭 링크
**$ ln [-s] 파일1 디렉터리 :** 파일1에 대한 링크를 지정된 디렉터리에 같은 이름으로 만들어 준다.

**하드링크**

기존 파일에 대한 새로운 이름, 기존 파일을 대표하는 i-노드를 가리켜 구현

**심볼릭 링크**

다른 파일을 가리키고 있는 별도의 파일, 실제 파일의 경로명을 저장하는 특수 파일(간접적 포인터 역할)

## 파일 입출력

### 시스템 호출(시스템 콜)

- 커널의 한 부분
- 유닉스 커널에 서비스를 요청하기 위한 프로그래밍 인터페이스
- 응용 프로그램은 시스템 호출을 통해 유닉스 커널에 서비스 요청

### 파일

- 디스크에 정보를 저장하기 위한 수단
- 유닉스 파일은 연속된 바이트 형태로 저장됨
- 종류
    - **텍스트 파일**
        - 문자들을 저장하고 있는 파일
        - 텍스트 파일에서 한줄의 끝(\n)은 파일이 읽어 들여질 때, C 내부 방식으로 변환
    - **이진 파일**
        - 모든 데이터는 있는 그래도 바이트의 연속으로 저장

### **C 언어의 파일의 입출력**

1. **fopen() : 파일 열기** → 파일을 사용하기 위해 **반드시** 사용해야 됨
    - 파일 열면 FILE 구조체에 대한 포인터 리턴, FILE 포인터는 열린 파일 지정
    - FILE *fopen(const char *filename, const char *mode);
    
    ```c
    File *fp;
    fp = fopen(~/work/text.txt", "r");
    ```
    
2. 파일 입출력 함수 사용
3. **fclose() : 파일 닫기 →** 파일을 열어서 사용 후에는 파일을 닫아야됨
    - int fclose(FILE *fp );
    - 성공 시 0, 오류 시 -1 반환
    
    ```c
    fclose(fp);
    ```
    

### 스트림과 FILE 구조체

**스트림** : 열린 파일

**FILE 구조체** : `stdio.h`에 정의 되어있음, 열린 파일의 현재 상태를 나타내는 필드 변수들

**표준 입출력 스트림**

- **stdin** : 표준 입력 (키보드)
- **stdout :** 표준 출력 (모니터)
- **stderr :** 표준 오류 (모니터)

### 파일 입출력 함수

![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8E%E1%85%AE%E1%86%AF%E1%84%85%E1%85%A7%E1%86%A8%208075bcd7b0f7404aa6836d67f26703b3/Untitled%204.png)

**문자 단위 입출력**

- **int fgetc(FILE *fp);**
    - getc 함수는 fp가 지정한 파일에서 한 문자를 읽어서 리턴한다.
    - 파일 끝 도달 시 EOF(-1) 리턴
- **int fputc(int c, FILE *fp);**
    - putc 함수는 파일에 한 문자씩 출력하는 함수
    - 리턴값으로 출력하는 문자 리턴
    - 출력 중 오류 발생 시 EOF(-1) 리턴

**줄 단위 입출력**

- **char* fgets(char *s, int n, FILE *fp);**
    - 파일로부터 한 줄을 읽어서 문자열 포인터 s에 저장, s 리턴
    - n 은 문자열의 길이
- **int fputs(const char *s, FILE *fp);**
    - 문자열 s를 fp가 나타내는 파일에 출력
    - 성공 시 바이트 수, 실패 시 EOF(-1) 리턴

```c
#include <stdio.h>
#include <stdlib.h>
#define MAXLINE 80

int main(int argc, char *argv[]) // 텍스트 파일에 줄 번호 붙여 프린트
{
	FILE *fp;
	int line = 0;
	char buffer[MAXLINE];
	
	if (argc != 2){
		fprintf(stderr, "사용법:line 파일이름\n");
		exit(1);
	}

	if ( (fp = fopen(argv[1],"r")) == NULL) {
		fprintf(stderr, "파일 열기 오류\n");
		exit(2);
	}

	while (fgets(buffer, MAXLINE, fp) != NULL) { // 한 줄 읽기
		line++;
		printf("%3d %s", line, buffer); // 줄번호와 함께 프린트
	}
	exit(0);
}
```