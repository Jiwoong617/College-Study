# 그래프 (3)

## 최단 경로 (shortest path)

네트워크에서 정점 u와 정점 v를 연결하는 경로 중에서 간선들의 **가중치 합이 최소가 되는 경로**

- 간선의 가중치는 비용, 거리, 시간 등이 있다.

### Dijkstra 알고리즘

**하나의 시작 정점에서** 모든 다른 정점까지의 최단 경로 계산

매 단계마다 가장 distance의 값이 작은 정점을 S에 추가

- **집합 S** : 최단 경로가 이미 발견된 정점들의 집합
- **distance[ ]** : 최단 경로가 알려진 정점들만을 이용한 다른 정점들까지의 최단 경로 길이

![Untitled](https://user-images.githubusercontent.com/101644572/171351970-e0a2ab84-b074-4507-8484-2155e8f23eb6.png)

1. 시작 정점 0을 S에 넣고 0에서 갈 수 있는 모든 경로의 길이를 distance에 넣음
2. distance에서 가장 작은 값을 골라 그 정점(4)를 넣고, 0과 0에서 4를 거쳐서 갈 수 있는 모든 경로의 길이를 distance에 넣음
3. distance에서 가장 작은 값을 골라 그 정점(1)를 넣고, 0, 0→4, 0→4→1를 거쳐서 갈 수 있는 모든 경로의 길이를 distance에 넣음
4. 위 과정을 계속 반복

**새로운 정점을 추가 하면 거리의 값이 “누적”된다고 생각하면 된다.**

네트워크에 n개의 정점이 →  주 반복문을 n번 반복, 내부 반복문을 2n번 반복

시간 복잡도 : $O(n^2)$

<br>

### Floyd 알고리즘

**모든 정점에서** 다른 모든 정점까지의 최단 경로를 계산 $A^k[i][j]$

0부터 k까지의 정점만 이용하여 i에서 j로 가는 최단 경로는 2가지로 나누어짐

- 정점 k를 거치는 경우
    - i에서 k까지의 최단거리 $A^{k-1}[i][k]$에 k에서 j까지의 최단거리 $A^{k-1}[k][j]$를 더한 값
- 정점 k를 거치지 않는 경우
    - 최단 거리는 여전히 $A^{k-1}[i][j]$

![Untitled 1](https://user-images.githubusercontent.com/101644572/171352017-bf54f917-ad66-4ec6-b027-6c347d547bdc.png)

```c
for(k=0; k<n; k++)
	for(i=0; i<n; i++)
		for(j=0; j<n; j++)
			if ( A[i][k] + A[k][j]  <  A[i][j] )
				A[i][j] = A[i][k] + A[k][j];
```

A[1][3] : 정점 1~3까지의 최단 거리를 구한다 하면, 경유점 k가 2가 되어 계산

- k를 거쳤을 때 값이 더 작으니 A[1][2] + A[2][3]이 된다.

네트워크에 n개의 정점 → 3중 반복문이 실행

시간 복잡도 : $O(n^3)$

<br>

### 위상정렬

**방향 그래프**의 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열 하는 것

![Untitled 2](https://user-images.githubusercontent.com/101644572/171352034-a138b0ca-4832-4801-81c7-315f93954dfe.png)

위와 같은 방향 그래프가 존재 시 위상 순서는

1. (0, 1, 2, 3, 4, 5)
2. (1, 0, 2, 3, 4, 5)
3. (1, 4, 0, 2, 3, 5)
4. (0, 2, 1, 3, 4, 5)
5. (0, 2, 1, 4, 3, 5)
6. (0, 1, 4, 2, 3, 5)
7. (1, 0, 2, 3, 4, 5)
8. (1, 0, 4, 2, 3, 5)

등이 있다.

**사이클이 존재하면 위상 정렬 불가**

**선행 정점을 가지면 그 정점은 위상 정렬 불가**
